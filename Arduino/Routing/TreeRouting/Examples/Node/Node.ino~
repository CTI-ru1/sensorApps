//XBee Libraries
#include <XBee.h>
#include <XbeeRadio.h>
//Create the XbeeRadio object we'll be using
XBeeRadio xbee;
// create a reusable response object for responses we expect to handle
XBeeRadioResponse response;
//Reusable response
Rx16Response rx;

#include <TreeRouting.h>
TreeRouting * routing;
// Variables will change:
int ledState = LOW;             // ledState used to set the LED
long previousMillis = 0;        // will store last time LED was updated
const int ledPin =  8;      // the number of the LED pin
int counter=0;

/**
 */
void radio_callback(char* topic, byte* payload, unsigned int length)
{
digitalWrite(9,HIGH);	
	  delay(10);
	  digitalWrite(9,LOW);	
}


void setup()
{
  //pinMode(13, OUTPUT);
  pinMode(9, OUTPUT);
  pinMode(8, OUTPUT);
  pinMode(7, OUTPUT);


//Connect to XBee
  xbee.initialize_xbee_module();
  xbee.begin(38400);
  //Initialize our XBee module with the correct values using channel 12
  xbee.init(12);

  routing= new TreeRouting(&xbee);
  routing->set_sink(false);
  
     uint16_t address = xbee.getMyAddress();
        uint8_t * bit = ((uint8_t*) & address);
        uint8_t mbyte = bit[1];
        uint8_t lbyte = bit[0];
        bit[0] = mbyte;
        bit[1] = lbyte;

	routing->set_my_address(address);
	routing->set_message_received_callback(radio_callback);

  if (address==0x9a8){
        digitalWrite(7,HIGH);
	delay(1000);
	digitalWrite(7,LOW);
	delay(1000);
	digitalWrite(7,HIGH);
	delay(1000);
	digitalWrite(7,LOW);
  }
  
}


void loop()
{

  routing->loop();

  
  switch (routing->state()){
    case 0:
    case 1: 
      digitalWrite(9,LOW);
      break;
    case 2: 
      digitalWrite(9,HIGH);    
      break;
  }
      
  unsigned long currentMillis = millis();
 
  if(currentMillis - previousMillis > 5000) {
    previousMillis = currentMillis;   
    counter;
    routing->sendGateway((byte*)&counter,1);
}
}
